# FuzzM User's Guide

FuzzM (Fuzzing with Models) is a gray box model-based fuzzing
framework that employs
[Lustre](https://en.wikipedia.org/wiki/Lustre_(programming_language))
as a modeling and specification language and leverages the
[JKind](https://github.com/agacek/jkindmodel) model checker as a
constraint solver.  Fuzzing a target system with FuzzM requires the
development of a Lustre _model_ and a _relay_.  The _model_ defines
the inputs to the system and specifies behaviors, in the form of
properties, that the fuzzer is expected to attack.  All of the vectors
generated by the framework should satisfy at least one of the
specified properties.  The _relay_ is responsible for interfacing with
the target and for re-formatting FuzzM test vectors so that they can
be transmitted to the target. A python relay class that knows how to
receive vectors from the fuzzer is provided.  Extending this class to
interface with a specific target essential in applying this framework.

## System Overview

FuzzM is a distributed framework consisting of the following components:

- The FuzzM Engine
- An AMQP Server
- The Relay

The FuzzM engine generates fuzzing test vectors based on a Lustre
model and sends them to the AMQP server.  The AMQP server enables
multiple producer/subscribers to generate or process the fuzzing data.
The Relay is responsible for interfacing with the fuzzing target,
pulling vectors from the AMQP server, reformatting the vectors, and
then passing them on to the target.

## The FuzzM Engine

The FuzzM engine is often started and stopped using Docker Compose.  It is
possible, however, to invoke it directly.

`java -ea -jar FuzzM/fuzzm/fuzzm/bin/fuzzm.jar -fuzzm [Options] /path/to/file.lus`

Or, using a UNIX script:

`FuzzM/fuzzm/scripts/fuzzm [Options] /path/to/file.lus`

The command line options for fuzzm are listed below:

```
usage: fuzzm [options] <input>
 -help            print this message
 -no_vectors      Suppress test vector generation (debug) [false]
 -solver <arg>    Use Only Specified Solver [null]
 -target <arg>    AMQP Address [null]
 -throttle        Throttle vector generation (debug) [false]
 -vectors <arg>   Number of vectors to generate (-1 = forever) [-1]
 -version         display version information
 -wdir <arg>      Path to temporary working directory [.]
```

Several options are intended only for debugging purposes and are so
indicated.  The most commonly used options are:

* `-target` This option is used to specify the URL of the AMQP server.
  If this option is not provided the fuzzer will not attempt to send 
  test vectors.

* `-wdir` This option is used to specify a location for use as a
  working directory for the fuzzer.  The default is the current
  working directory.

* `-solver` The solver option is used to limit the solver used by
  FuzzM.  This is especially useful if the model contains features
  supported only by a limited subset of solvers.  This option can
  appear several times on the command line to enable a set of solvers.
  The default is to use any of the solvers supported by JKind that are
  currently installed which may include SMTInterpol (default), Z3,
  CVC4, Yices, Yices2, and MathSAT.

### The Model

The Lustre model drives the fuzzing process.  Each test vector generated
by the fuzzer will consist of an assignment of values to each of the inputs
of the model.  As a result, the inputs of the Lustre model should correspond
in some way with the inputs of the target system.  An example Lustre model
is provided with the fsm demo [here](examples/fsm-demo/fsm.lus).

There are two inputs to the fsm model, 'length' and 'msg'.  

```
node main(length: byte; msg: fsm_msg) returns ();
```

The 'msg' input abstracts the actual UDP payload into named
fields that are used in constructing the model.  Note that the
hierarchical names used here also appear in the relay code below
(ie: 'length' and msg.buff[2]').


```C
type fsm_msg = struct
{
  magic0 : byte;
  magic1 : byte;
  seq    : byte;
  cmd    : byte;
  buff   : byte[16]
};
```

Assertions are used in the model to establish the types (value bounds) on the inputs.

```
  --
  -- Value type constraints
  --
  assert(0 <= length     and length     <= 20);
  assert(0 <= msg.magic0 and msg.magic0 < 256);
  assert(0 <= msg.magic1 and msg.magic1 < 256);
  assert(0 <= msg.seq    and msg.seq    < 256);
  assert(0 <= msg.cmd    and msg.cmd    < 16);
  assert(0 <= msg.buff[ 0] and msg.buff[ 0] < 256);
```

The body of the Lustre model captures the expected behaviors of the target system.
Compare the behavior below with the the fsm [specification](examples/fsm-model/SPEC.md).

```
  --
  -- State Machine
  --
  next_st = (if (cmd_reset) then 0 else
             if (st0 and st0_ok) then (if (cmd_hello) then 1 else 0) else
             if (st1 and st1_ok) then (if (cmd_data)  then 2 else 1) else
             if (st2 and st2_ok) then (if (cmd_file)  then 3 else 2) else
             if (st3 and st3_ok) then (if (cmd_disco) then 4 else 3) else
             0);

  st = st0() -> (pre next_st);
```

Finally, properties are used to drive the fuzzer to explore target behaviors.
Every test vector generated by the fuzzer will satisfy one of the properties
specified in the Lustre file.

```
  fuzz_st0_ok   = FUZZ(st0_pre_ok and st0_ok);
  fuzz_st0_off0 = FUZZ(st0_pre_ok                                                                        );
  fuzz_st0_off1 = FUZZ(st0_pre_ok and               magic1_ok and seq_ok and st0_cmd_ok and st0_length_ok);
  fuzz_st0_off2 = FUZZ(st0_pre_ok and magic0_ok and               seq_ok and st0_cmd_ok and st0_length_ok);
  fuzz_st0_off3 = FUZZ(st0_pre_ok and magic0_ok and magic1_ok and            st0_cmd_ok and st0_length_ok);
  fuzz_st0_off4 = FUZZ(st0_pre_ok and magic0_ok and magic1_ok and seq_ok and st0_cmd_ok and st0_length_ok);
  fuzz_st0_off5 = FUZZ(st0_pre_ok and magic0_ok and magic1_ok and seq_ok and                st0_length_ok);
  fuzz_st0_off6 = FUZZ(st0_pre_ok and magic0_ok and magic1_ok and seq_ok and st0_cmd_ok                  );

  --%PROPERTY fuzz_st0_ok   ;
  --%PROPERTY fuzz_st0_off0 ;
  --%PROPERTY fuzz_st0_off1 ;
  --%PROPERTY fuzz_st0_off2 ;
  --%PROPERTY fuzz_st0_off3 ;
  --%PROPERTY fuzz_st0_off4 ;
  --%PROPERTY fuzz_st0_off5 ;
  --%PROPERTY fuzz_st0_off6 ;
```

## The AMQP Server

An AMQP server is started along with the FuzzM engine when invoked via Docker Compose.

## The Relay

The relay will typically either extend or employ the python [base receiver](../base-receiver/README.md) class
provided with this distribution. The distribution also provides two example relays, one in each
of the [fsm](examples/fsm-model/README.md) and [tftp](examples/tftp-model/README.md) directories.
The examples below are from the fsm [relay](examples/fsm-model/relay.py).

The interface to the relay will vary with each application of FuzzM.
Typically, however, the relay will at least need to know the URL of
the AMQP server.  The fsm relay accepts the IP of the AMQP server and
the IP/port of the target.

```python
def main():
    parser = argparse.ArgumentParser(description="FSM Relay")
    parser.add_argument('-f', '--fuzz',
                        required=True,
                        help="The address of the fuzzer (AMQP server)")
    parser.add_argument('-ti', '--target_ip',
                        required=True,
                        help="The target IP")
    parser.add_argument('-tp', '--target_port',
                        required=True,
                        help="The target port")
    args = parser.parse_args()

    relay(args.fuzz, args.target_ip, args.target_port)
```

Note that
the base class provides methods to initialize and start a receiver thread
as well as methods to synchronize with the fuzzer.  Once the receiver is
started, the main job of the relay is to get the next test vector, reformat
it, and send it to the target.

```python
def relay(fuzz_ip, target_ip, target_port):
    ## Initialize the base receiver
    fuzz_receiver = relay_receiver.RelayReceiver(fuzz_ip)
    ## Start the receiver
    fuzz_receiver.start()
    ## Synchronize with the fuzzer
    spec = fuzzer_resync(fuzz_receiver)
    
    ## Forever ..
    while True:
        ## Get the next test vector ..
        msg = nextMessage(fuzz_receiver, spec)
        ## Reformat it ..
        pkt = IP(dst=target_ip)/UDP(dport=int(target_port))/Raw(load=bytes(msg))
        ## Send it to the target.
        send(pkt)
```

The 'nextMessage' method from the fsm [relay](examples/fsm-model/relay.py) requests
a raw test vector from the receiver, transforms it into a dictionary, and
then re-formats the data as a UDP packet payload.  For reference, compare the
code below to the fsm specification of the expected UDP [payload](examples/fsm-model/SPEC.md).
Note that the dictionary
is indexed by strings that reflect the hierarchical names used in the Lustre model
above. Structures and arrays are flattened into their primitive integer, Boolean (0 or 1), or
rational (N/D) components.

```python
def nextMessage(fuzz_receiver, spec):
    msg = bytearray(0)
    while True:
        ## Get a vector from the fuzzer ..
        raw_test_vector = fuzz_receiver.get_next_test_vector()
        ## Represent it as a dictionary ..
        test_vector = FuzzMRatSignal(raw_test_vector, spec)
        
        # print("[Relay] vector = " + str(test_vector))
        
        ## Reformat dictionary into appropriate target payload ..
        try:
            length = int(test_vector['length'])
            if not (0 <= length and length < 32):
                print("[Relay] Length field out of bounds [0,32] : " + str(length))
                print(test_vector)
                continue
            msg = bytearray(length)
            if (0 < length):
                msg[0] = int(test_vector['msg.magic0'])
            if (1 < length):
                msg[1] = int(test_vector['msg.magic1'])
            if (2 < length):
                msg[2] = int(test_vector['msg.seq'])
            if (3 < length):
                msg[3] = int(test_vector['msg.cmd'])
            for index in range(0,length-4):
                name = 'msg.buff[' + str(index) + ']'
                byte = int(test_vector[name])
                msg[4 + index] = byte
        except KeyError:
            print("[Relay] Key Error Accessing Message :")
            print(test_vector)
            continue
        break
    return msg

```

## Operation

Docker and Docker Compose are used to simplify the deployment of the
FuzzM framework.  To run the fsm example, go to the `FuzzM/examples/fsm-model`
directory and type:

```
docker-compose up
```

To verify the operation of the fuzzer, connect a web browser to
`http://<docker host>:15672`.  If docker is running on your local
machine, this would be `http://localhost:15672`

You will need to log in to the AMQP server as user `guest` with
password `guest`.  After logging in the web page should show activity
in the AMQP queues that reflects fuzzing activity, as in the green bar
on the graph in the image below.

![Server](img/mq-server.png)

To terminate the fuzzing session, type:

`docker-compose down`
